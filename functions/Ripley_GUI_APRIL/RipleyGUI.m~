function varargout = RipleyGUI(varargin)
% Run by typing RipleyGUI
% License: RipleyGUI is distributed free under the conditions that
% (1) it shall not be incorporated in software that is subsequently sold; 
% (2) the authorship of the software shall be acknowledged in any publication that uses results generated by the software; 
% (3) this notice shall remain in place in each source file. 


% RIPLEYGUI M-file for RipleyGUI.fig
%      RIPLEYGUI, by itself, creates a new RIPLEYGUI or raises the existing
%      singleton*.
%
%      H = RIPLEYGUI returns the handle to a new RIPLEYGUI or the handle to
%      the existing singleton*.
%
%      RIPLEYGUI('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in RIPLEYGUI.M with the given input arguments.
%
%      RIPLEYGUI('Property','Value',...) creates a new RIPLEYGUI or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before RipleyGUI_OpeningFunction gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to RipleyGUI_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Copyright 2002-2003 The MathWorks, Inc.

% Edit the above text to modify the response to help RipleyGUI

% Last Modified by GUIDE v2.5 21-Mar-2011 11:23:47

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @RipleyGUI_OpeningFcn, ...
                   'gui_OutputFcn',  @RipleyGUI_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before RipleyGUI is made visible.
function RipleyGUI_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to RipleyGUI (see VARARGIN)

% Choose default command line output for RipleyGUI
handles.output = hObject;

% Update handles structure
guidata(hObject, handles);

% UIWAIT makes RipleyGUI wait for user response (see UIRESUME)
% uiwait(handles.figure1);

movegui('north')


% --- Outputs from this function are returned to the command line.
function varargout = RipleyGUI_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;


function size_x_Callback(hObject, eventdata, handles)
% hObject    handle to size_x (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of size_x as text
%        str2double(get(hObject,'String')) returns contents of size_x as a double


% --- Executes during object creation, after setting all properties.
function size_x_CreateFcn(hObject, eventdata, handles)
% hObject    handle to size_x (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end



function size_y_Callback(hObject, eventdata, handles)
% hObject    handle to size_y (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of size_y as text
%        str2double(get(hObject,'String')) returns contents of size_y as a double


% --- Executes during object creation, after setting all properties.
function size_y_CreateFcn(hObject, eventdata, handles)
% hObject    handle to size_y (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end



function size_z_Callback(hObject, eventdata, handles)
% hObject    handle to size_z (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of size_z as text
%        str2double(get(hObject,'String')) returns contents of size_z as a double


% --- Executes during object creation, after setting all properties.
function size_z_CreateFcn(hObject, eventdata, handles)
% hObject    handle to size_z (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


% --- Executes on button press in radiobutton_po.
function radiobutton_po_Callback(hObject, eventdata, handles)
% hObject    handle to radiobutton_po (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of radiobutton_po


% --- Executes on button press in radiobutton_po_cl.
function radiobutton_po_cl_Callback(hObject, eventdata, handles)
% hObject    handle to radiobutton_po_cl (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of radiobutton_po_cl


% --- Executes on button press in radiobutton_inhib.
function radiobutton_inhib_Callback(hObject, eventdata, handles)
% hObject    handle to radiobutton_inhib (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of radiobutton_inhib


function po_cl_lambda_Callback(hObject, eventdata, handles)
% hObject    handle to po_cl_lambda (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of po_cl_lambda as text
%        str2double(get(hObject,'String')) returns contents of po_cl_lambda as a double


% --- Executes during object creation, after setting all properties.
function po_cl_lambda_CreateFcn(hObject, eventdata, handles)
% hObject    handle to po_cl_lambda (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end



function po_cl_s_lambda_Callback(hObject, eventdata, handles)
% hObject    handle to po_cl_s_lambda (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of po_cl_s_lambda as text
%        str2double(get(hObject,'String')) returns contents of po_cl_s_lambda as a double


% --- Executes during object creation, after setting all properties.
function po_cl_s_lambda_CreateFcn(hObject, eventdata, handles)
% hObject    handle to po_cl_s_lambda (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end



function inhib_delta_Callback(hObject, eventdata, handles)
% hObject    handle to inhib_delta (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of inhib_delta as text
%        str2double(get(hObject,'String')) returns contents of inhib_delta as a double


% --- Executes during object creation, after setting all properties.
function inhib_delta_CreateFcn(hObject, eventdata, handles)
% hObject    handle to inhib_delta (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end



function inhib_lambda_Callback(hObject, eventdata, handles)
% hObject    handle to inhib_lambda (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of inhib_lambda as text
%        str2double(get(hObject,'String')) returns contents of inhib_lambda as a double


% --- Executes during object creation, after setting all properties.
function inhib_lambda_CreateFcn(hObject, eventdata, handles)
% hObject    handle to inhib_lambda (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end



function po_cl_e_distance_Callback(hObject, eventdata, handles)
% hObject    handle to po_cl_e_distance (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of po_cl_e_distance as text
%        str2double(get(hObject,'String')) returns contents of po_cl_e_distance as a double


% --- Executes during object creation, after setting all properties.
function po_cl_e_distance_CreateFcn(hObject, eventdata, handles)
% hObject    handle to po_cl_e_distance (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


% --- Executes on button press in create_pushbutton.
function create_pushbutton_Callback(hObject, eventdata, handles)
% hObject    handle to create_pushbutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% Read the user params and create a distribution.
res = helpf_create_dist(hObject, eventdata, handles);
if res == 0
    return;
end
handles = guidata(hObject);

X = handles.X;
Y = handles.Y;
Z = handles.Z;

% Plot the new distribution
axes(handles.axes1)
scatter3(X,Y,Z,'.r'), drawnow; axis equal,grid on
xlabel('X'), ylabel('Y'), zlabel('Z')


% Empty outdated plots
axes(handles.axes2)
plot(0,0)
if isfield(handles,'ripK')
    handles = rmfield(handles,'ripK');
end
set(handles.distname, 'String', '');
% Updating list of available plots
set(handles.choose_kplot_listbox,'String',{});
set(handles.choose_kplot_listbox,'Value',0);

%always update the GUI
guidata(hObject, handles);


% ---  Help function are not bound to any GUI object or action
function res = helpf_create_dist(hObject, eventdata, handles)

res = 1; %success is default

% Getting parameters and checking them
[x_side okx] = str2num(get(handles.size_x,'String'));
[y_side oky] = str2num(get(handles.size_y,'String'));
[z_side okz] = str2num(get(handles.size_z,'String'));
if okx*oky*okz == 0 || isreal([x_side y_side z_side]) == 0 || sum(isfinite([x_side y_side z_side])) ~= 3 
    errordlg('Size values not valid','Input error');
    res = 0;
    return;
end
if x_side <= 0 || y_side <= 0 || z_side <= 0
    errordlg('Size must be positive','Input error');
    res = 0;
    return;
end

% Create Poisson distribution
if get(handles.radiobutton_po ,'Value')
    lambda = str2double(get(handles.po_lambda,'String'));
    if isreal(lambda) == 0 || isfinite(lambda) == 0 || lambda <= 0
        errordlg('Lambda value not valid','Input error');
        res = 0;
    return;
    end
    if x_side*y_side*z_side*lambda > 1000000
        answer = questdlg('More than one million events. Continue anyway?','Input Warning');
        if isequal(answer,'Yes') == 0
            res = 0;
            return;
        end
    end
    Pdist = create_po_distribution(lambda, x_side, y_side, z_side);
     if isempty(Pdist)
        errordlg('Distribution too small (0)','Usage error');
        res = 0;
        return;
    end
    X = Pdist(:,1);
    Y = Pdist(:,2);
    Z = Pdist(:,3);
end

% Create Poisson Cluster distribution
if get(handles.radiobutton_po_cl ,'Value')
    lambda = str2double(get(handles.po_cl_lambda,'String'));
    if isreal(lambda) == 0 || isfinite(lambda) == 0 || lambda <= 0
        errordlg('Lambda value not valid','Input error');
        res = 0;
        return;
    end
    S_lambda = str2double(get(handles.po_cl_s_lambda,'String'));
    if isreal(S_lambda) == 0 || isfinite(S_lambda) == 0 || S_lambda <= 0
        errordlg('S_lambda value not valid','Input error');
        res = 0;
        return;
    end
    E_distance = str2double(get(handles.po_cl_e_distance,'String'));
    if isreal(E_distance) == 0 || isfinite(E_distance) == 0 || E_distance <= 0
        errordlg('E_distance value not valid','Input error');
        res = 0;
        return;
    end
    if x_side*y_side*z_side*lambda > 1000000
        answer = questdlg('More than one million events. Continue anyway?','Input Warning');
        if isequal(answer,'Yes') == 0
            res = 0;
            return;
        end
    end
    PCdist = create_po_cl_distribution(lambda, S_lambda, E_distance, x_side,y_side,z_side);
    if isempty(PCdist)
        res = 0;
        return;
    end
    X = PCdist(:,1);
    Y = PCdist(:,2);
    Z = PCdist(:,3);
end

% Create Simple Inhibition distribution
if get(handles.radiobutton_inhib ,'Value')
    lambda = str2double(get(handles.inhib_lambda,'String'));
    if isreal(lambda) == 0 || isfinite(lambda) == 0 || lambda <= 0
        errordlg('Lambda value not valid','Input error');
        res = 0;
        return;
    end
    delta = str2double(get(handles.inhib_delta,'String'));
    if isreal(delta) == 0 || isfinite(delta) == 0 || delta <= 0
        errordlg('Delta value not valid','Input error');
        res = 0;
        return;
    end
    req_pack_intensity = lambda*delta^3*2*pi/3;
    if(req_pack_intensity > 0.5) % not enough space for distribution
        errordlg('There is not space for so many so sparse events. Try lower intensity or less inhibition','Input error');
        res = 0;
        return;
    end
    if x_side*y_side*z_side*lambda > 1000000
        answer = questdlg('More than one million events. Continue anyway?','Input Warning');
        if isequal(answer,'Yes') == 0
            res = 0;
            return;
        end
    end
    Idist = create_inhib_distribution(lambda, delta, x_side,y_side,z_side);
     if isempty(Idist)
        errordlg('Distribution too small (0)','Usage error');
        res = 0;
        return;
    end
    X = Idist(:,1);
    Y = Idist(:,2);
    Z = Idist(:,3);
end

% Create Inhibited Poisson Cluster distribution
if get(handles.cluster_inhib ,'Value')
    lambda = str2double(get(handles.inhib_po_cl_lambda,'String'));
    if isreal(lambda) == 0 || isfinite(lambda) == 0 || lambda <= 0
        errordlg('Lambda value not valid','Input error');
        res = 0;
        return;
    end
    S_lambda = str2double(get(handles.inhib_po_cl_slambda,'String'));
    if isreal(S_lambda) == 0 || isfinite(S_lambda) == 0 || S_lambda <= 0
        errordlg('S_lambda value not valid','Input error');
        res = 0;
        return;
    end
    E_distance = str2double(get(handles.inhib_po_cl_edistance,'String'));
    if isreal(E_distance) == 0 || isfinite(E_distance) == 0 || E_distance <= 0
        errordlg('E_distance value not valid','Input error');
        res = 0;
        return;
    end
    delta = str2double(get(handles.inhib_po_cl_delta,'String'));
    if isreal(delta) == 0 || isfinite(delta) == 0 || delta <= 0
        errordlg('Delta value not valid','Input error');
        res = 0;
        return;
    end
    req_pack_intensity = lambda*delta^3*2*pi/3;
    if(req_pack_intensity > 0.5) % not enough space for distribution
        errordlg('There is not space for so many so sparse events. Try lower intensity or less inhibition','Input error');
        res = 0;
        return;
    end
    if x_side*y_side*z_side*lambda > 1000000
        answer = questdlg('More than one million events. Continue anyway?','Input Warning');
        if isequal(answer,'Yes') == 0
            res = 0;
            return;
        end
    end
    IPCdist = create_inhib_po_cl_distribution(lambda, S_lambda,0, E_distance,delta, x_side,y_side,z_side);
    if isempty(IPCdist)
        res = 0;
        return;
    end
    X = IPCdist(:,1);
    Y = IPCdist(:,2);
    Z = IPCdist(:,3);
end

% Saving the distribution
handles.X = X;
handles.Y = Y;
handles.Z = Z;

%always update the GUI
guidata(hObject, handles);



function po_lambda_Callback(hObject, eventdata, handles)
% hObject    handle to po_lambda (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of po_lambda as text
%        str2double(get(hObject,'String')) returns contents of po_lambda as a double


% --- Executes during object creation, after setting all properties.po
function po_lambda_CreateFcn(hObject, eventdata, handles)
% hObject    handle to po_lambda (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


% --- Executes on button press in new_window.
function new_window_Callback(hObject, eventdata, handles)
% hObject    handle to new_window (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

if isfield(handles,'X') == 0
    return
end 

figure
scatter3(handles.X, handles.Y, handles.Z,'.r'), drawnow; axis equal,grid on
xlabel('X'), ylabel('Y'), zlabel('Z')


% --- Executes on button press in station.
function station_Callback(hObject, eventdata, handles)
% hObject    handle to station (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

if isfield(handles,'X') == 0
    errordlg('You must load or create a distribution first','Usage error');
    return;
end

station_dist = station(station([handles.X handles.Y handles.Z],0),0);
handles.X = station_dist(:,1);
handles.Y = station_dist(:,2);
handles.Z = station_dist(:,3);
axes(handles.axes1)
scatter3(handles.X, handles.Y, handles.Z,'.r'), drawnow; axis equal,grid on
xlabel('X'), ylabel('Y'), zlabel('Z')

% Empty outdated plots
axes(handles.axes2)
plot(0,0)
if isfield(handles,'ripK')
    handles = rmfield(handles,'ripK');
end
% Updating list of available plots
set(handles.choose_kplot_listbox,'String',{});
set(handles.choose_kplot_listbox,'Value',0);


% always update the GUI
guidata(hObject, handles);


% --- Executes on button press in ripleyk.
function ripleyk_Callback(hObject, eventdata, handles)
% hObject    handle to ripleyk (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Variable reading and error handling
if isfield(handles,'X') == 0
    errordlg('You must load or create a distribution first','Usage error');
    return;
end
max_t = str2double(get(handles.t_value,'String'));
if isreal(max_t) == 0 || isfinite(max_t) == 0 || max_t <= 0
    errordlg('max_t value not valid','Input error');
    return;
end
smallest_side = min([max(handles.X)-min(handles.X) max(handles.Y)-min(handles.Y) max(handles.Z)-min(handles.Z)]);
if max_t >= smallest_side/2;
    answer = questdlg('max_t should not be bigger than half of the smallest side. Continue anyway?','Input error');
    if isequal(answer,'Yes') == 0
        return;
    end
end
step_t = str2double(get(handles.t_step,'String'));
if isreal(step_t) == 0 || isfinite(step_t) == 0 || step_t <= 0
    errordlg('step_t value not valid','Input error');
    return;
end
if step_t >= max_t
    errordlg('step_t value must be smaller than max_t','Input error');
    return;
end

% Calculating the K function
rip = ripleyK_comuse([handles.X handles.Y handles.Z], step_t:step_t:max_t, 0);
if isstruct(rip) == 0
    return;
end
if isfield(rip,'K')*isfield(rip,'EK') == 0
    errordlg('There was a problem calculating the K function. Please check your distribution and t values','Callback error');
    return;
end

% Plotting the K_function_minus_E
axes(handles.axes2)
plot(step_t:step_t:max_t,rip.K-rip.EK,'-sb','LineWidth',2,'MarkerEdgeColor','k','MarkerFaceColor','b','MarkerSize',2)
drawnow; grid on,xlabel('t'),ylabel('K(t)-E[K(t)]')

% Updating list of available plots
plotlist{1} = 'K_function_minus_E';
plotlist{2} = 'K_function_divide_E';
plotlist{3} = 'K_function';
set(handles.choose_kplot_listbox,'String',plotlist);
set(handles.choose_kplot_listbox,'Value',1);

% Save the ripley K values
handles.ripK = rip.K;
handles.EK = rip.EK;
handles.maxT = max_t;
handles.stepT = step_t;

% always update the GUI
guidata(hObject, handles);

function t_value_Callback(hObject, eventdata, handles)
% hObject    handle to t_value (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of t_value as text
%        str2double(get(hObject,'String')) returns contents of t_value as a double


% --- Executes during object creation, after setting all properties.
function t_value_CreateFcn(hObject, eventdata, handles)
% hObject    handle to t_value (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


% --------------------------------------------------------------------
function load_mat_menu_Callback(hObject, eventdata, handles)
% hObject    handle to load_mat_menu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%allow the user to specify where to load the settings file
[filename, pathname] = uigetfile('*.mat', 'Pick a file');
    if isequal(filename,0) | isequal(pathname,0)
       return
    end
       
%construct the path name of the save location
loadDataName = fullfile(pathname,filename);

%this is the gui that will be closed once we load the new settings
theCurrentGUI = gcf;  
 
%load the settings, which creates a new gui
hgload(loadDataName); 

%closes the old gui
close(theCurrentGUI);

% Moving to uppper central posotion
movegui('north')

% --------------------------------------------------------------------
function load_ascii_menu_Callback(hObject, eventdata, handles)
% hObject    handle to load_ascii_menu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%allow the user to specify where to load the settings file
[filename, pathname] = uigetfile('*.ascii', 'Pick a file');
    if isequal(filename,0) | isequal(pathname,0)
       return
    end
       
%construct the path name of the save location
loadDataName = fullfile(pathname,filename);

try
    dlmres = dlmread(loadDataName);
catch
    error_msg{1} = 'Cant read file. Please check the format';
    error_msg{2} = lasterr;
    errordlg(error_msg,'File error');
    return;
end
if size(dlmres,2) < 3 
    errordlg('The input doesnt have the expected format. Expected three columns delimited with comma, space or tab','File error');
    return;
end
if any(any(isnan(dlmres))) || any(any(isinf(dlmres)))
    errordlg('Input file contains non-finite numbers','File error');
    return;
end
if size(dlmres,1) < 3 
    errordlg('At least 3 events are requiered in each distribution','File error');
    return;
end
handles.X = dlmres(:,1);
handles.Y = dlmres(:,2);
handles.Z = dlmres(:,3);

axes(handles.axes1)
scatter3(handles.X, handles.Y, handles.Z,'.r'), drawnow; axis equal,grid on
xlabel('X'), ylabel('Y'), zlabel('Z')


% Empty outdated plots
axes(handles.axes2)
plot(0,0)
if isfield(handles,'ripK')
    handles = rmfield(handles,'ripK');
end

% Use filename as name
set(handles.distname, 'String', filename);

% Updating list of available plots
set(handles.choose_kplot_listbox,'String',{});
set(handles.choose_kplot_listbox,'Value',0);

% always update the gui
guidata(hObject, handles);


% --------------------------------------------------------------------
function save_menu_Callback(hObject, eventdata, handles)
% hObject    handle to save_menu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%allow the user to specify where to save the settings file
[filename,pathname] = uiputfile('*.mat','Save your GUI state, distributions and K values');
 
if pathname == 0 %if the user pressed cancelled, then we exit this callback
    return
end
%construct the path name of the save location
saveDataName = fullfile(pathname,filename);

%saves the gui data
hgsave(saveDataName);


% --------------------------------------------------------------------
function file_menu_Callback(hObject, eventdata, handles)
% hObject    handle to file_menu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)



function t_step_Callback(hObject, eventdata, handles)
% hObject    handle to t_step (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of t_step as text
%        str2double(get(hObject,'String')) returns contents of t_step as a double


% --- Executes during object creation, after setting all properties.
function t_step_CreateFcn(hObject, eventdata, handles)
% hObject    handle to t_step (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end



% --- Executes on button press in pval.
function pval_Callback(hObject, eventdata, handles)
% hObject    handle to pval (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of pval

% Get values and control them
if isfield(handles,'X') == 0
    errordlg('You must load or create a distribution first','Usage error');
    return;
end
X = handles.X;
Y = handles.Y;
Z = handles.Z;
if isfield(handles,'ripK') == 0
    errordlg('You must estimate K before comparing to CSR','Usage error');
    return;
end
ripK = handles.ripK;
EK = handles.EK;
maxT = handles.maxT;
stepT = handles.stepT;
[simulations ok] = str2num(get(handles.simulations,'String'));
if ok == 0 || isreal(simulations) == 0 || isfinite(simulations) == 0 || simulations <= 0
    errordlg('simulations value not valid','Input error');
    return;
end

% Create random distributions
% and calculate their K-values
t = stepT:stepT:maxT;
K_array = zeros(simulations,length(t));
datacsr_sizeX = max(X) - min(X);
datacsr_sizeY = max(Y) - min(Y);
datacsr_sizeZ = max(Z) - min(Z);
datacsr_points = length(X);
datacsr_lambda = length(X)/(datacsr_sizeX*datacsr_sizeY*datacsr_sizeZ);
h_pvalwait = waitbar(0,'Simulating CSR distributions...');
for i=1:simulations
    datacsr=create_po_distribution(datacsr_lambda, datacsr_sizeX, datacsr_sizeY, datacsr_sizeZ);
    if isempty(datacsr)
        errordlg('The simulated distribution is empty. Maybe intensity is too low?','Callback Error');
        close(h_pvalwait);
        return;
    end
    csr_ripK=ripleyK_comuse(datacsr,t,0,0);
    K_array(i,:) = csr_ripK.K;
    try
        waitbar(i/simulations, h_pvalwait);       
    catch
        helpdlg('Calculations had been aborted','Waitbar message')
        return;
    end
end
close(h_pvalwait);

% Calculate the P values
p = pval(ripK,K_array,t);

% Plot the p-values
axes(handles.axes2)
hold off, plot(t,p,'g','LineWidth',3), hold on, grid on
hold on, plot(t,repmat(0.05,1,length(t)),'--k','LineWidth',3)
title('Difference has significance below black line')
xlabel('t'),ylabel('p')
hold off

% Updating list of available plots
plotlist{1} = 'K_function_minus_E';
plotlist{2} = 'K_function_divide_E';
plotlist{3} = 'K_function';
plotlist{4} = 'Compare_K_functions';
plotlist{5} = 'Compare_P_value';
set(handles.choose_kplot_listbox,'String',plotlist);
set(handles.choose_kplot_listbox,'Value',5);

% Save the values
handles.sims = simulations;
handles.P = p;
handles.simsK = K_array;

%set toogle state
set(hObject,'Value',0);
% always update the GUI
guidata(hObject, handles);


function simulations_Callback(hObject, eventdata, handles)
% hObject    handle to simulations (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of simulations as text
%        str2double(get(hObject,'String')) returns contents of simulations as a double


% --- Executes during object creation, after setting all properties.
function simulations_CreateFcn(hObject, eventdata, handles)
% hObject    handle to simulations (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


% --- Executes on button press in K_new_window.
function K_new_window_Callback(hObject, eventdata, handles)
% hObject    handle to K_new_window (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get choosen plot
if isfield(handles,'choose_kplot_listbox') == 0
    return
end
plotlist = get(handles.choose_kplot_listbox,'String');
chosen = get(handles.choose_kplot_listbox,'Value');
if chosen==0
    return
end

% Plot it
figure
switch plotlist{chosen}
    case 'K_function_minus_E'
        % Getting saved values
        step_t = handles.stepT;
        max_t = handles.maxT;
        ripK = handles.ripK;
        EK = handles.EK;
        % Plotting
        plot(step_t:step_t:max_t,ripK-EK,'o-b','LineWidth',2,'MarkerEdgeColor','k','MarkerFaceColor','b','MarkerSize',2)
        drawnow; grid on,xlabel('t'),ylabel('K(t) - E[K(t)]')

    case 'K_function_divide_E'
        % Getting saved values
        step_t = handles.stepT;
        max_t = handles.maxT;
        ripK = handles.ripK;
        EK = handles.EK;
        % Plotting
        plot(step_t:step_t:max_t,ripK./EK,'o-r','LineWidth',2,'MarkerEdgeColor','k','MarkerFaceColor','r','MarkerSize',2)
        drawnow; grid on,xlabel('t'),ylabel('K(t)/E[K(t)]')

    case 'K_function'
        % Getting saved values
        step_t = handles.stepT;
        max_t = handles.maxT;
        ripK = handles.ripK;
        % Plotting
        plot(step_t:step_t:max_t,ripK,'o-r','LineWidth',2,'MarkerEdgeColor','k','MarkerFaceColor','r','MarkerSize',2)
        drawnow; grid on,xlabel('t'),ylabel('K(t)')
  
        
    case 'Compare_K_functions'
        % Getting saved values
        t = handles.stepT:handles.stepT:handles.maxT;
        ripK = handles.ripK;
        simulations = handles.sims;
        K_array = handles.simsK;
        % Plotting
        hold off, plot(t,ripK,'-r'), hold on
        for i=1:simulations
            plot(t,K_array(i,:),'-b')
        end
        plot(t,ripK,'-r')
        title(['Blue: CSR.',10, 'Red: Tested distribution'])
        xlabel('t'),ylabel('K(t)'), grid on
        hold off

    case 'Compare_P_value'
        % Getting saved values
        t = handles.stepT:handles.stepT:handles.maxT;
        p = handles.P;
        % Plotting
        hold off, plot(t,p,'g','LineWidth',3), hold on, grid on
        hold on, plot(t,repmat(0.05,1,length(t)),'--k','LineWidth',3)
        title('Difference has significance below black line')
        xlabel('t'),ylabel('p')
        hold off

    otherwise

end

function distname_Callback(hObject, eventdata, handles)
% hObject    handle to distname (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of distname as text
%        str2double(get(hObject,'String')) returns contents of distname as a double


% --- Executes during object creation, after setting all properties.
function distname_CreateFcn(hObject, eventdata, handles)
% hObject    handle to distname (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


% --- Executes on selection change in choose_kplot_listbox.
function choose_kplot_listbox_Callback(hObject, eventdata, handles)
% hObject    handle to choose_kplot_listbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: contents = get(hObject,'String') returns choose_kplot_listbox contents as cell array
%        contents{get(hObject,'Value')} returns selected item from choose_kplot_listbox



plotlist = get(hObject,'String');
chosen = get(hObject,'Value');

axes(handles.axes2)
switch plotlist{chosen}
    case 'K_function_minus_E'
        % Getting saved values
        step_t = handles.stepT;
        max_t = handles.maxT;
        ripK = handles.ripK;
        EK = handles.EK;
        % Plotting
        plot(step_t:step_t:max_t,ripK-EK,'o-b','LineWidth',2,'MarkerEdgeColor','k','MarkerFaceColor','b','MarkerSize',2)
        drawnow; grid on,xlabel('t'),ylabel('K(t) - E[K(t)]')

    case 'K_function_divide_E'
        % Getting saved values
        step_t = handles.stepT;
        max_t = handles.maxT;
        ripK = handles.ripK;
        EK = handles.EK;
        % Plotting
        plot(step_t:step_t:max_t,ripK./EK,'o-r','LineWidth',2,'MarkerEdgeColor','k','MarkerFaceColor','r','MarkerSize',2)
        drawnow; grid on,xlabel('t'),ylabel('K(t)/E[K(t)]')
   
    case 'K_function'
        % Getting saved values
        step_t = handles.stepT;
        max_t = handles.maxT;
        ripK = handles.ripK;
        % Plotting
        plot(step_t:step_t:max_t,ripK,'o-r','LineWidth',2,'MarkerEdgeColor','k','MarkerFaceColor','r','MarkerSize',2)
        drawnow; grid on,xlabel('t'),ylabel('K(t)')
  
    case 'Compare_K_functions'
        % Getting saved values
        t = handles.stepT:handles.stepT:handles.maxT;
        ripK = handles.ripK;
        simulations = handles.sims;
        K_array = handles.simsK;
        % Plotting
        hold off, plot(t,ripK,'-r'), hold on
        for i=1:simulations
            plot(t,K_array(i,:),'-b')
        end
        plot(t,ripK,'-r')
        title(['Blue: CSR.',10, 'Red: Tested distribution'])
        xlabel('t'),ylabel('K(t)'), grid on
        hold off
     
    case 'Compare_P_value'
        % Getting saved values
        t = handles.stepT:handles.stepT:handles.maxT;
        p = handles.P;
        % Plotting
        hold off, plot(t,p,'g','LineWidth',3), hold on, grid on
        hold on, plot(t,repmat(0.05,1,length(t)),'--k','LineWidth',3)
        title('Difference has significance below black line')
        xlabel('t'),ylabel('p')
        hold off
        
    otherwise
        
end
        



% --- Executes during object creation, after setting all properties.
function choose_kplot_listbox_CreateFcn(hObject, eventdata, handles)
% hObject    handle to choose_kplot_listbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: listbox controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


% --- Executes on selection change in set_listbox.
function set_listbox_Callback(hObject, eventdata, handles)
% hObject    handle to set_listbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: contents = get(hObject,'String') returns set_listbox contents as cell array
%        contents{get(hObject,'Value')} returns selected item from set_listbox


% --- Executes during object creation, after setting all properties.
function set_listbox_CreateFcn(hObject, eventdata, handles)
% hObject    handle to set_listbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: listbox controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


% --- Executes on button press in add_to_set.
function add_to_set_Callback(hObject, eventdata, handles)
% hObject    handle to add_to_set (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Check that a distribution exists
if isfield(handles,'X') == 0
    errordlg('No distribution to add','Usage Error')
    return
end

% Check the name
name = get(handles.distname,'String');
if isempty(name)
    errordlg('You must specify a name','Input Error');
    return
end


% Find a position
% Last if new name, replacing old name if already exists
set_list = get(handles.set_listbox,'String');

% Get the chosen set
option = get(handles.chooseset,'Value');

%get length of chosen set
if isfield(handles,'set') && length(handles.set) >= option
    dists_in_chosen = length(handles.set{option});
else
    dists_in_chosen = 0;
end

if sum(strcmp(set_list,name)) == 0
    % the name is new
    position = dists_in_chosen+1;
    handles.dists_in_set = dists_in_chosen+1;
else
    % a distribution is to be replaced
    [position C_unused] = find(strcmp(set_list,name));
    handles.dists_in_set = dists_in_chosen;
end

% Save the distribution
handles.set{option}{position}.X = handles.X;
handles.set{option}{position}.Y = handles.Y;
handles.set{option}{position}.Z = handles.Z;
handles.set{option}{position}.name = name;

% Empty K-values
handles.set_iscomplete{option} = 0; % K-values for set must be re-estimated

% Add to listbox
set_list{position} = name;
set(handles.set_listbox,'String',set_list);
set(handles.set_listbox,'Value',position);

% Save K-value if calculated
if isfield(handles,'ripK')
    handles.set{option}{position}.ripK = handles.ripK;
    handles.set{option}{position}.EK = handles.EK;
    handles.set{option}{position}.maxT = handles.maxT;
    handles.set{option}{position}.stepT = handles.stepT;
    
    % fill t boxes for sets
    set(handles.all_stept, 'String', handles.stepT);
    set(handles.all_maxt, 'String', handles.maxT);
end

% always update the GUI
guidata(hObject, handles);


% --- Executes on button press in view_from_set.
function view_from_set_Callback(hObject, eventdata, handles)
% hObject    handle to view_from_set (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% Get the chosen set
option = get(handles.chooseset,'Value');

% Check listbox choice
if isfield(handles,'set_listbox') == 0
    return
end 
distlist = get(handles.set_listbox,'String');
chosen = get(handles.set_listbox,'Value');
if chosen==0 || chosen > length(distlist)
    errordlg('Couldnt view distribution.','Error');
    return
end

% Move the information from marked set to current set
helpf_get_dist_from_set(hObject, eventdata, handles);
handles = guidata(hObject);

% always update the GUI
guidata(hObject, handles);


% --- Executes on button press in meanK.
function meanK_Callback(hObject, eventdata, handles)
% hObject    handle to meanK (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of meanK

% Check that there are distributions
if isfield(handles,'set_listbox') == 0
    return
end 
distlist = get(handles.set_listbox,'String');
%chosen = get(handles.set_listbox,'Value');

% Get the chosen set
option = get(handles.chooseset,'Value');

%get length of chosen set
if isfield(handles,'set') && length(handles.set) >= option && length(handles.set{option}) > 0
    dists_in_chosen = length(handles.set{option});
else
    return;
end
 
% Read and check t values
max_t = str2double(get(handles.all_maxt,'String'));
if isreal(max_t) == 0 || isfinite(max_t) == 0 || max_t <= 0
    errordlg('max_t value not valid','Input error');
    return;
end
step_t = str2double(get(handles.all_stept,'String'));
if isreal(step_t) == 0 || isfinite(step_t) == 0 || step_t <= 0
    errordlg('step_t value not valid','Input error');
    return;
end
if step_t >= max_t
    errordlg('step_t value must be smaller than max_t','Input error');
    return;
end

% Initialize K_array
K_array = zeros(dists_in_chosen,floor(max_t/step_t));
nbr_of_events = zeros(1,dists_in_chosen);
% Calculate missing K-values
handle_wb = waitbar(0,'Please wait...');
for i=1:dists_in_chosen
    nbr_of_events(i) = length(handles.set{option}{i}.X);
    try
        waitbar((i-1)/dists_in_chosen, handle_wb, ['Processing ' handles.set{option}{i}.name])
    catch
        helpdlg('Calculations had been aborted','Waitbar message')
        return;
    end
    
    if isfield(handles.set{option}{i},'ripK')
        if handles.set{option}{i}.stepT == step_t && handles.set{option}{i}.maxT >= max_t
            handles.set{option}{i}.ripK = handles.set{option}{i}.ripK(1:floor(max_t/step_t));
            handles.set{option}{i}.EK = handles.set{option}{i}.EK(1:floor(max_t/step_t));
            handles.set{option}{i}.maxT = max_t;
            K_array(i,:) = handles.set{option}{i}.ripK;
            continue;
        end
    end
    X = handles.set{option}{i}.X;
    Y = handles.set{option}{i}.Y;
    Z = handles.set{option}{i}.Z;
       
    % Calculating the K function and check the result
    rip = ripleyK_comuse([X Y Z], step_t:step_t:max_t, 0,0);
    if isstruct(rip) == 0
        return;
    end
    if isfield(rip,'K')*isfield(rip,'EK') == 0
        errordlg('There was a problem calculating the K function. Please check your distribution and t values','Callback error');
        return;
    end
    
    % save result to correct set
    handles.set{option}{i}.ripK = rip.K;
    handles.set{option}{i}.EK = rip.EK;
    handles.set{option}{i}.stepT = step_t;
    handles.set{option}{i}.maxT = max_t;
    K_array(i,:) = handles.set{option}{i}.ripK;
end

close(handle_wb) % close the waitbar

% Calculate mean K
% save calculated Ks for comparation
if size(K_array,1) == 1
    meanK = K_array;
else
    nbr_of_events = nbr_of_events';
    meanK = wa(K_array,nbr_of_events);
end
handles.set_iscomplete{option} = 1;
handles.set_stept{option} = step_t;
handles.set_maxt{option} = max_t;
handles.set_K_array{option} = K_array;
handles.set_meanK{option} = meanK;
handles.set_nbrofevents{option} = nbr_of_events;


% plot the result
desiredWidth = 1000;
desiredHeight = 300;
figure('Name',['K-function for set ' num2str(option)],'Position',getNorthPosition(desiredWidth, desiredHeight));
color = ['g' 'r' 'b'];
EK = handles.set{option}{1}.EK;

subplot(1,3,1), hold on, grid on
for i=1:size(K_array,1)
    plot(step_t:step_t:max_t, K_array(i,:),['-' color(option)])
end
plot(step_t:step_t:max_t, meanK,['-s' color(option)],'LineWidth',2,'MarkerEdgeColor','k','MarkerFaceColor',color(option),'MarkerSize',2)
xlabel('t'),ylabel('K(t)'),title('Weighted Average')

subplot(1,3,2), hold on, grid on
for i=1:size(K_array,1)
    plot(step_t:step_t:max_t, K_array(i,:)-EK,['-' color(option)])
end
plot(step_t:step_t:max_t, meanK - EK,['-s' color(option)],'LineWidth',2,'MarkerEdgeColor','k','MarkerFaceColor',color(option),'MarkerSize',2)
xlabel('t'),ylabel('K(t) - E(K(t))'),title('Weighted Average')

subplot(1,3,3), hold on, grid on
for i=1:size(K_array,1)
    plot(step_t:step_t:max_t, K_array(i,:)./EK,['-' color(option)])
end
plot(step_t:step_t:max_t, meanK ./ EK,['-s' color(option)],'LineWidth',2,'MarkerEdgeColor','k','MarkerFaceColor',color(option),'MarkerSize',2)
xlabel('t'),ylabel('K(t) / E(K(t))'),title('Weighted Average')

% Remove bootstrapping values if any
if isfield(handles,'set_boots') && length(handles.set_boots) >= option && length(handles.set_boots{option}) > 0
    handles.set_boots{option} = [];
end

% set toogle state
set(hObject,'Value',0);

% always update the GUI
guidata(hObject, handles);
    

function all_maxt_Callback(hObject, eventdata, handles)
% hObject    handle to all_maxt (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of all_maxt as text
%        str2double(get(hObject,'String')) returns contents of all_maxt as a double


% --- Executes during object creation, after setting all properties.
function all_maxt_CreateFcn(hObject, eventdata, handles)
% hObject    handle to all_maxt (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end



function all_stept_Callback(hObject, eventdata, handles)
% hObject    handle to all_stept (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of all_stept as text
%        str2double(get(hObject,'String')) returns contents of all_stept as a double


% --- Executes during object creation, after setting all properties.
function all_stept_CreateFcn(hObject, eventdata, handles)
% hObject    handle to all_stept (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


% --------------------------------------------------------------------
function load_folder_Callback(hObject, eventdata, handles)
% hObject    handle to load_folder (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%allow the user to specify where to load the settings file
dirname = uigetdir('', 'Pick a folder containing ascii file distributions');
    if isequal(dirname,0)
       return
    end
       
%construct the path name
loadDataName = fullfile(dirname,'*.ascii');
%list all data files in the folder
filelist = dir(loadDataName);

% Check set selection
option = get(handles.chooseset,'Value');

%Count previous distributions in set
if isfield(handles,'set') && length(handles.set) >= option
    dists_in_set = length(handles.set{option});
else
    dists_in_set = 0;
end

for i = 1:length(filelist)
    if (~filelist(i).isdir)
        filename = filelist(i).name;
        
        % Check the file is valid
        try
            data = dlmread(fullfile(dirname, filename));
        catch
            error_msg{1} = filename;
            error_msg{2} = 'Cant read file. Please check the format';
            error_msg{3} = lasterr;
            errordlg(error_msg,'File error');
            continue;
        end
        if size(data,2) < 3
            error_msg{1} = filename;
            error_msg{2} =  'The input doesnt have the expected format.';
            error_msg{3} = 'Expected three columns delimited with comma, space or tab';
            errordlg(error_msg ,'File error');
            continue;
        end
        if size(data,1) < 3 
            error_msg{1} = filename;
            error_msg{2} = 'At least three events are requiered in each distribution. Skipping.';
            errordlg(error_msg, 'File error');
            continue;
        end
        if any(any(isnan(data))) || any(any(isinf(data)))
            error_msg{1} = filename;
            error_msg{2} = 'Input file contains non-finite numbers';
            errordlg(error_msg,'File error');
            continue;
        end
        
        % Get data from the file
        X = data(:,1);
        Y = data(:,2);
        Z = data(:,3);
        
        % Find a position
        % Last if new name, replacing old name if already exists
        set_list = get(handles.set_listbox,'String');
        if sum(strcmp(set_list,filename)) == 0
            % the name is new
            position = dists_in_set+1;
            handles.dists_in_set = dists_in_set+1;
            dists_in_set = dists_in_set+1;
        else
            % a distribution is to be replaced
            [position C_unused] = find(strcmp(set_list,filename));
        end

        % Save the data to the set
        handles.set{option}{position}.X = X;
        handles.set{option}{position}.Y = Y;
        handles.set{option}{position}.Z = Z;
        handles.set{option}{position}.name = filename;
        
        % Update the listbox
        set_list{position} = filename;
        set(handles.set_listbox,'String',set_list);

        % always update the GUI
        guidata(hObject, handles);
                
    end
end

% K-values for set must be re-estimated
handles.set_iscomplete{option} = 0;

if dists_in_set > 0
    set(handles.set_listbox,'Value',1);
end

% always update the GUI
guidata(hObject, handles);

% --------------------------------------------------------------------
function Set_Callback(hObject, eventdata, handles)
% hObject    handle to Set (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --- Executes on selection change in chooseset.
function chooseset_Callback(hObject, eventdata, handles)
% hObject    handle to chooseset (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: contents = get(hObject,'String') returns chooseset contents as cell array
%        contents{get(hObject,'Value')} returns selected item from chooseset

% Get the choosen set from dropdown
option = get(hObject,'Value');


% Build namelist from correct set
namelist = {};
if isfield(handles,'set') && length(handles.set) >= option
    elements = length(handles.set{option});
else
    elements = 0;
end
for i=1:elements
    namelist{i} = handles.set{option}{i}.name;
end

% update the listbox
set(handles.set_listbox,'String',namelist);
if elements > 0
    set(handles.set_listbox,'Value',1);
else
    set(handles.set_listbox,'Value',0);
end


% always update the GUI
guidata(hObject, handles);

% --- Executes during object creation, after setting all properties.
function chooseset_CreateFcn(hObject, eventdata, handles)
% hObject    handle to chooseset (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


% --- Executes on button press in compare_sets.
function compare_sets_Callback(hObject, eventdata, handles)
% hObject    handle to compare_sets (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of compare_sets

% Read the checkboxes
checked(1) = get(handles.checkbox1, 'Value');
checked(2) = get(handles.checkbox2, 'Value');
checked(3) = get(handles.checkboxcsr, 'Value');

% Count how many are checked
if sum(checked) <= 1
    errordlg('Too few checked sets','Usage Error');
    return
end

% Check that all checked have K values defined and the same t values
for i=1:3
    if checked(i)
        if isfield(handles,'set_iscomplete') == 0 || length(handles.set_iscomplete) < i || handles.set_iscomplete{i} == 0
            errordlg('All checked sets dont have complete K values');
            return;
        end
        if exist('stepT')
            if stepT ~= handles.set_stept{i} || maxT ~= handles.set_maxt{i}
                errordlg('The sets you compare need to have the same step size and max t');
                return;
            end
        else
            stepT = handles.set_stept{i};
            maxT = handles.set_maxt{i};
        end
    end
end

t = stepT:stepT:maxT;
EK = 4/3*pi*t.^3;
% Check that all have been bootstrapped
for i=1:3
    if checked(i)
        if isfield(handles,'set_boots') == 0 || length(handles.set_boots) < i || length(handles.set_boots{i}) == 0
            errordlg('All checked sets dont have bootstrapped confidence intervals','Usage Error')
            return
        end
    end
end   

% Do the plotting
desiredWidth = 1000; desiredHeight = 600;
figure('Name','Comparing sets','Position',getNorthPosition(desiredWidth, desiredHeight))
color = ['g' 'r' 'b'];
infotext = [];
for i=1:3
    if checked(i)

        % All K_array and mean K
        subplot(2,3,1)
        hold on
        plot(0, 0, 'Color', 'g', 'Linewidth', 2)
        plot(0, 0, 'Color', 'r', 'Linewidth', 2)
        plot(0, 0, 'Color', 'b', 'Linewidth', 2)
        legend('Set 1','Set 2','Set 3','Location','NorthW');
        for j=1:size(handles.set_K_array{i},1)
            plot(t, handles.set_K_array{i}(j,:),['-' color(i)])
        end
        plot(t, handles.set_meanK{i},['-s' color(i)],'LineWidth',2,'MarkerEdgeColor','k','MarkerFaceColor',color(i),'MarkerSize',2)
        xlabel('t'),ylabel('K(t)'), title('All K-values')
        
        subplot(2,3,2)
        hold on
        for j=1:size(handles.set_K_array{i},1)
            plot(t, handles.set_K_array{i}(j,:)-EK,['-' color(i)])
        end
        plot(t, handles.set_meanK{i}-EK,['-s' color(i)],'LineWidth',2,'MarkerEdgeColor','k','MarkerFaceColor',color(i),'MarkerSize',2)
        xlabel('t'),ylabel('K(t) - E(K(t))'), title('All K-values')
        
        % mean K and confidence intervals
%         subplot(2,3,2)
%         hold on
%         plot(t, handles.set_meanK{i}, 'Color', color(i), 'Linewidth', 2)
%         plot(t, handles.set_low{i}, 'Color', color(i), 'Linewidth', 1, 'Linestyle', '-.')
%         plot(t, handles.set_up{i}, 'Color', color(i), 'Linewidth', 1, 'Linestyle', '-.')
%         xlabel('t'),ylabel('K(t)'),title('95% confidence interval')
        
        subplot(2,3,3)
        hold on
        plot(t, handles.set_meanK{i}-EK, 'Color', color(i), 'Linewidth', 2)
        plot(t, handles.set_low{i}-EK, 'Color', color(i), 'Linewidth', 1, 'Linestyle', '-.')
        plot(t, handles.set_up{i}-EK, 'Color', color(i), 'Linewidth', 1, 'Linestyle', '-.')
        xlabel('t'),ylabel('K(t)-E(K(t))'),title('95% confidence interval')
        
    end
end


% set toogle state
set(hObject,'Value',0);

% always update the GUI
guidata(hObject, handles);



% --- Executes on button press in checkbox1.
function checkbox1_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checkbox1


% --- Executes on button press in checkbox2.
function checkbox2_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checkbox2


% --- Executes on button press in checkboxcsr.
function checkboxcsr_Callback(hObject, eventdata, handles)
% hObject    handle to checkboxcsr (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checkboxcsr


% --------------------------------------------------------------------
function fill_CSR_menu_Callback(hObject, eventdata, handles)
% hObject    handle to fill_CSR_menu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


amount = 20; %number of distributions to add

% Initialize list of distribution
dist_list = {};


for i=1:amount
    % Read the user params and create a distribution.
    res = helpf_create_dist(hObject, eventdata, handles);
    if res == 0
        return;
    end
    handles = guidata(hObject);
    X = handles.X;
    Y = handles.Y;
    Z = handles.Z;
    name = ['dist-' num2str(i)];
    dist_list{i}.X = X;
    dist_list{i}.Y = Y;
    dist_list{i}.Z = Z;
    dist_list{i}.name = name;
end


% Get chosen set
option = get(handles.chooseset,'Value');

% Save the distribution
for i = 1:amount
    handles.set{option}{i} = [];
    handles.set{option}{i}.X = dist_list{i}.X;
    handles.set{option}{i}.Y = dist_list{i}.Y;
    handles.set{option}{i}.Z = dist_list{i}.Z;
    handles.set{option}{i}.name = dist_list{i}.name;
    handles.set_iscomplete{option} = 0; % K-values for set must be re-estimated
end
% Update listbox
set_list = {};
for i = 1:amount
    set_list{i} = dist_list{i}.name;
end
set(handles.set_listbox,'String',set_list);
set(handles.set_listbox,'Value', 1);


% always update the GUI
guidata(hObject, handles);


% --- Executes on button press in remove_from_set.
function remove_from_set_Callback(hObject, eventdata, handles)
% hObject    handle to remove_from_set (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get the chosen set
option = get(handles.chooseset,'Value');

% Check listbox choice
if isfield(handles,'set_listbox') == 0
    return
end 
distlist = get(handles.set_listbox,'String');
chosen = get(handles.set_listbox,'Value');
if chosen==0 || chosen > length(distlist)
    errordlg('Couldnt view distribution.','Error');
    return
end

% Move the information from marked set to current set
helpf_get_dist_from_set(hObject, eventdata, handles);
handles = guidata(hObject);

% Remove the dist from listbox
distlist(chosen) = [];
set(handles.set_listbox,'String',distlist);

% remove the dist from set
handles.set{option}(chosen) = [];

% Check the marked dist is within range
if chosen > length(handles.set{option})
    set(handles.set_listbox,'Value',chosen-1);
end

% always update the GUI
guidata(hObject, handles);

% ---  Help function are not bound to any GUI object or action
function res = helpf_get_dist_from_set(hObject, eventdata, handles)

% Get the chosen set
option = get(handles.chooseset,'Value');

% Check listbox choice
if isfield(handles,'set_listbox') == 0
    res = 0;
    return
end 
distlist = get(handles.set_listbox,'String');
chosen = get(handles.set_listbox,'Value');
if chosen==0 || chosen > length(distlist)
    errordlg('Couldnt view distribution.','Error');
    res = 0;
    return
end

% Plot the distribution
handles.X = handles.set{option}{chosen}.X;
handles.Y = handles.set{option}{chosen}.Y;
handles.Z = handles.set{option}{chosen}.Z;
axes(handles.axes1)
scatter3(handles.X, handles.Y, handles.Z,'.r'), drawnow; axis equal,grid on
xlabel('X'), ylabel('Y'), zlabel('Z')
set(handles.distname, 'String', distlist{chosen});

% Save K-values and show options if calculated
if isfield(handles.set{option}{chosen},'ripK')
    handles.ripK = handles.set{option}{chosen}.ripK;
    handles.EK = handles.set{option}{chosen}.EK;
    handles.stepT = handles.set{option}{chosen}.stepT;
    handles.maxT = handles.set{option}{chosen}.maxT;

    % Plotting the K_function_minus_E
    step_t = handles.stepT;
    max_t = handles.maxT;
    ripK = handles.ripK;
    EK = handles.EK;
    axes(handles.axes2)
    plot(step_t:step_t:max_t,ripK-EK,'-sb','LineWidth',2,'MarkerEdgeColor','k','MarkerFaceColor','b','MarkerSize',2)
    drawnow; grid on,xlabel('t'),ylabel('K(t)-E[K(t)]')
    
    % Showing the t-values
    set(handles.t_step,'String',num2str(step_t));
    set(handles.t_value,'String',num2str(max_t));

    % Updating list of available plots
    plotlist{1} = 'K_function_minus_E';
    plotlist{2} = 'K_function_divide_E';
    plotlist{3} = 'K_function';
    set(handles.choose_kplot_listbox,'String',plotlist);
    set(handles.choose_kplot_listbox,'Value',1);
else
    % empty the K-values
    axes(handles.axes2)
    plot(0,0)
    if isfield(handles,'ripK')
        handles = rmfield(handles,'ripK');
    end
    set(handles.choose_kplot_listbox,'String',{});
    set(handles.choose_kplot_listbox,'Value',0);
end

% always update the GUI
guidata(hObject, handles);


% --- Executes on button press in empty_set.
function empty_set_Callback(hObject, eventdata, handles)
% hObject    handle to empty_set (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Warn the user
question{1} = 'Remove all distributions in this set?';
confirm = questdlg(question);
if isequal(confirm,'Yes') == 0
    % set toogle state
    set(hObject,'Value',0);
    return;
end

% Get the chosen set
option = get(handles.chooseset,'Value');

% empty the listbox
set(handles.set_listbox,'String',{});

% remove the dist from set
handles.set{option} = {};

% K-values for set must be re-estimated
handles.set_iscomplete{option} = 0;
    
% set toogle state
set(hObject,'Value',0);

% always update the GUI
guidata(hObject, handles);


% --------------------------------------------------------------------
function export_menu_Callback(hObject, eventdata, handles)
% hObject    handle to export_menu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Check there is a distribution
if isfield(handles,'X') == 0
    errordlg('No distribbution to export','Usage Error');
    return
end
X = handles.X;
Y = handles.Y;
Z = handles.Z;

% export the distribution
assignin('base', 'ripGUI_dist', [X Y Z])
infomsg{1} = 'The distribution have been exported to your Matlab workspace.';
infomsg{2} = '';
infomsg{3} = 'ripGUI_dist: The X,Y,Z positions';

% export K-function if calculated
if isfield(handles,'ripK')
    ripK = handles.ripK;
    EK = handles.EK;
    t = handles.stepT:handles.stepT:handles.maxT;
    assignin('base', 'ripGUI_ripK', ripK)
    assignin('base', 'ripGUI_EK', EK)
    assignin('base', 'ripGUI_t', t)
    infomsg{4} = 'ripGUI_ripK: Values of ripleys K-function';
    infomsg{5} = 'ripGUI_EK: Expected K-values under CSR, for comparation';
    infomsg{6} = 'ripGUI_t: t-values that K was calculated for';
    infomsg{7} = '';
    infomsg{8} = 'Try eg. plot(ripGUI_t, ripGUI_ripK-ripGUI_EK)';
end

helpdlg(infomsg,'Export succesful')


% --------------------------------------------------------------------
function export_set_menu_Callback(hObject, eventdata, handles)
% hObject    handle to export_set_menu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get the chosen set
option = get(handles.chooseset,'Value');

% Export the set to workspace
if isfield(handles,'set') && length(handles.set) >= option
    assignin('base', ['ripGUI_set' num2str(option)], handles.set{option});
    infomsg{1} = ['Set ' num2str(option) ' have been exported to your Matlab workspace.'];
    infomsg{2} = '';
    infomsg{3} = ['ripGUI_set' num2str(option)];
    infomsg{4} = '';
    infomsg{5} = ['eg. ripGUI_set' num2str(option) '{1} shows all available data for the first distribution'];
    helpdlg(infomsg,'Export succesful')
else
    errordlg('Set is empty','Export failed');
end


% --- Executes on button press in bootstrap_set.
function bootstrap_set_Callback(hObject, eventdata, handles)
% hObject    handle to bootstrap_set (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get the chosen set
option = get(handles.chooseset,'Value');

% Check that K-values are calculated
if isfield(handles,'set_iscomplete') == 0 || length(handles.set_iscomplete) < option || handles.set_iscomplete{option} == 0
    errordlg('You must first calculate K values');
    return;
end

% Get t and K values
stepT = handles.set_stept{option};
maxT = handles.set_maxt{option};
t=stepT:stepT:maxT;
K_array = handles.set_K_array{option};
nbr_of_events = handles.set_nbrofevents{option};
K_weighted = handles.set_meanK{option};

% Residuals
res=resid(K_array, nbr_of_events, K_weighted);
handles.set_residuals{option} = res;

% Bootstrap
boots=kboot(K_array,nbr_of_events, res, 5000,'within');
if boots == 0
    helpdlg('Calculation has been aborted','Abort message');
    return;
end
handles.set_boots{option} = boots;


% confidence interval and variance
[low up var] = kci(boots);
handles.set_low{option} = low;
handles.set_up{option} = up;
handles.set_var{option} = var;

% Do the plotting
desiredWidth = 1000; desiredHeight = 300;
figure('Name',['Bootstrapped residuals for set ' num2str(option)],'Position',getNorthPosition(desiredWidth, desiredHeight));
color = ['g' 'r' 'b'];
EK = handles.set{option}{1}.EK;

subplot(1,3,1), hold on, grid on
plot(t,K_weighted,'Color',color(option),'LineWidth',2)
plot(t,low,'Color',color(option),'LineStyle','-.','LineWidth',1)
plot(t,up,'Color',color(option),'LineStyle','-.','LineWidth',1)
xlabel('t'),ylabel('K(t)'),title('95% confidence interval')

subplot(1,3,2), hold on, grid on
plot(t,K_weighted-EK,'Color',color(option),'LineWidth',2)
plot(t,low-EK,'Color',color(option),'LineStyle','-.','LineWidth',1)
plot(t,up-EK,'Color',color(option),'LineStyle','-.','LineWidth',1)
xlabel('t'),ylabel('K(t) - E(K(t))'),title('95% confidence interval')

subplot(1,3,3), hold on, grid on
plot(t,K_weighted./EK,'Color',color(option),'LineWidth',2)
plot(t,low./EK,'Color',color(option),'LineStyle','-.','LineWidth',1)
plot(t,up./EK,'Color',color(option),'LineStyle','-.','LineWidth',1)
xlabel('t'),ylabel('K(t) / E(K(t))'),title('95% confidence interval')

% always update the GUI
guidata(hObject, handles);


% --- Executes on button press in set_compare_CSR.
function set_compare_CSR_Callback(hObject, eventdata, handles)
% hObject    handle to set_compare_CSR (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get the chosen set
option = get(handles.chooseset,'Value');

% Check that K-values are calculated
if isfield(handles,'set_iscomplete') == 0 || length(handles.set_iscomplete) < option || handles.set_iscomplete{option} == 0
    errordlg('You must first calculate K values');
    return;
end

% Check that bootstrapped values are generated
if isfield(handles,'set_boots') == 0 || length(handles.set_boots) < option || length(handles.set_boots{option}) == 0
    errordlg('You must first calculate bootstrapped confidence intervals','Usage Error')
    return;
end

% Get t and K values
stepT = handles.set_stept{option};
maxT = handles.set_maxt{option};
t=stepT:stepT:maxT;
K_array = handles.set_K_array{option};
nbr_of_events = handles.set_nbrofevents{option};
K_weighted = handles.set_meanK{option};

[simulations ok] = str2num(get(handles.set_simulations,'String'));
if ok == 0 || isreal(simulations) == 0 || isfinite(simulations) == 0 || simulations <= 0
    errordlg('simulations value not valid','Input error');
    return;
end

% Mean size and intensity of distributions
[sidex sidey sidez lambda] = Get_params(handles.set{option});

% Check if CSR K-values are calculated
if isfield(handles,'latest_CSR_K_array') && handles.latest_CSR_stept == stepT && handles.latest_CSR_maxt >= maxT
    CSR_K_array = handles.latest_CSR_K_array(:,1:floor(maxT/stepT));
    
 
    question{1} = ['You already have: ' num2str(size(CSR_K_array,1)) ' CSR distributions with'];
    question{2} = ['lamda = ' num2str(handles.latest_CSR_lambda) ' (Your lambda: ' num2str(lambda) ')'];
    question{3} = ['side X = ' num2str(handles.latest_CSR_x) ' (Your X side: ' num2str(sidex) ')'];
    question{4} = ['side Y = ' num2str(handles.latest_CSR_y) ' (Your Y side: ' num2str(sidey) ')'];
    question{5} = ['side Z = ' num2str(handles.latest_CSR_z) ' (Your Z side: ' num2str(sidez) ')'];
    question{6} = '';
    question{7} = 'Do you want to use these distributions? Reusing CSR distributions will save time but is not recommended if lambda or the cube size are to different.'; 
    answer = questdlg(question,'CSR Set','Cancel','Make all new', 'Use existing','Use existing');
    if isequal(answer,'Use existing')
        calculated_K = size(CSR_K_array,1);
    elseif isequal(answer,'Cancel')
        return;
    else
        calculated_K = 0;
    end
    
else
    calculated_K = 0;
end


% Create random distributions
% and calculate their K-values
t = stepT:stepT:maxT;
CSR_K_array(calculated_K+1:simulations,:) = zeros(simulations-calculated_K,length(t));
h_pvalwait = waitbar(calculated_K/simulations,'Simulating CSR distributions...');
for i=calculated_K+1:simulations
    datacsr=create_po_distribution(lambda, sidex, sidey, sidez);
    csr_ripK = ripleyK_comuse(datacsr,t,0,0);
    CSR_K_array(i,:) = csr_ripK.K;
    try
        waitbar(i/simulations, h_pvalwait);
    catch
        helpdlg('Calculations had been aborted','Waitbar message')
        return;
    end
end
waitbar(0.95, h_pvalwait,'Comparing...');

% Save the calculated random distributions.
handles.latest_CSR_K_array = CSR_K_array;
handles.latest_CSR_stept = stepT;
handles.latest_CSR_maxt = maxT;
handles.latest_CSR_lambda = lambda;
handles.latest_CSR_x = sidex;
handles.latest_CSR_y = sidey;
handles.latest_CSR_z = sidez;

%plot in new window
desiredWidth = 700; desiredHeight = 600;
figure('Name',['Comparing set ' num2str(option) ' with CSR'],'Position',getNorthPosition(desiredWidth, desiredHeight))
color = ['g' 'r' 'b'];
EK = handles.set{option}{1}.EK;
subplot(2,2,1)
hold on, grid on
for i=1:simulations
    plot(t,CSR_K_array(i,:)-EK,'Color','black');
end
plot(t,K_weighted-EK,'-s','Color',color(option),'LineWidth',2,'MarkerEdgeColor','k','MarkerSize',2)
xlabel('t'),ylabel('K(t) - E(K(t))'),title(['CSR in black',10, 'Set weighted average in color'])

% Calculate the P values
[p x f] = pval(K_weighted,CSR_K_array,t);

% Plot the p-values
subplot(2,2,2)
hold on, grid on 
plot(t,p,color(option),'LineWidth',3)
plot(t,repmat(0.05,1,length(t)),'--k','LineWidth',3)
title(['P values',10,'Difference has significance below black line'])
xlabel('t'),ylabel('p')

% Calculate bootstrap for the CSR distribution
csr_nbr_of_events = ones(size(CSR_K_array,1),1) *lambda*sidex*sidey*sidez;
CSR_K_weighted = wa(CSR_K_array,csr_nbr_of_events);
csr_res=resid(CSR_K_array, csr_nbr_of_events, CSR_K_weighted);
csr_boots=kboot(CSR_K_array,csr_nbr_of_events, csr_res, 5000,'within');
[csr_low csr_up csr_var] = kci(csr_boots);

% Plot the residuals
subplot(2,2,3)
hold on, grid on 
plot(t,K_weighted - EK,'-s','Color',color(option),'LineWidth',2,'MarkerEdgeColor','k','MarkerSize',2)
plot(t,CSR_K_weighted - EK,'-s','Color','k','LineWidth',2,'MarkerEdgeColor','k','MarkerSize',2)
plot(t, handles.set_low{option} - EK, 'Color', color(option), 'Linewidth', 1, 'Linestyle', '-.')
plot(t, handles.set_up{option} - EK, 'Color', color(option), 'Linewidth', 1, 'Linestyle', '-.')
plot(t, csr_low - EK, 'Color', 'k', 'Linewidth', 1, 'Linestyle', '-.')
plot(t, csr_up - EK, 'Color', 'k', 'Linewidth', 1, 'Linestyle', '-.')
xlabel('t'),ylabel('K(t) - E(K(t))'),title(['CSR interval in black',10, 'Set interval in color'])

% Do the BBTSS comparation
t=stepT:stepT:maxT;
res=resid(K_array,nbr_of_events,K_weighted);
res_csr = resid(CSR_K_array,csr_nbr_of_events, CSR_K_weighted);
boots=kboot({K_array CSR_K_array},{nbr_of_events csr_nbr_of_events},{res res_csr},1000,'between');
result=btss({K_array CSR_K_array},{nbr_of_events csr_nbr_of_events},t,boots);
btss_p=result.p;
BTSS=result.BTSS;
xBTSS=result.BTSSdist(1,:);
fBTSS=result.BTSSdist(2,:);

close(h_pvalwait);

% Plot the btss-values
subplot(2,2,4)
hold on, grid on 
plot(xBTSS,fBTSS,'k','LineWidth',3)
plot(BTSS,0,'ks','MarkerSize',10,'MarkerFaceColor','r')
title(['Between Group comparations', 10, 'P-value =' num2str(btss_p)]);
xlabel('Bootstrapped BTSS values')
ylabel('Accumulated probability')
% set toogle state
set(hObject,'Value',0);

% always update the GUI
guidata(hObject, handles);



function set_simulations_Callback(hObject, eventdata, handles)
% hObject    handle to set_simulations (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of set_simulations as text
%        str2double(get(hObject,'String')) returns contents of set_simulations as a double


% --- Executes during object creation, after setting all properties.
function set_simulations_CreateFcn(hObject, eventdata, handles)
% hObject    handle to set_simulations (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


% --- Executes on button press in divide.
function divide_Callback(hObject, eventdata, handles)
% hObject    handle to divide (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of divide

% Get current distribution
if isfield(handles,'X') == 0
    errordlg('You must load or create a distribution first','Usage error');
    return;
end
dist = [handles.X handles.Y handles.Z];

% Create divisions
divided = divide(dist, 0);

% Get current set
option = get(handles.chooseset,'Value');
if isfield(handles,'set') && length(handles.set) >= option
    old_dists = length(handles.set{option});
else
    old_dists = 0;
end

% Get the name
name = get(handles.distname,'String');
if isempty(name)
    errordlg('You must specify a name','Input Error');
    return
end

% Get the list fromthe listbox
dist_list = get(handles.set_listbox,'String');

% Add all to current set
for i=1:length(divided)
    divided{i} = station(station(divided{i},0),0);
    handles.set{option}{i+old_dists}.X = divided{i}(:,1);
    handles.set{option}{i+old_dists}.Y = divided{i}(:,2);
    handles.set{option}{i+old_dists}.Z = divided{i}(:,3);
    handles.set{option}{i+old_dists}.name = [name '-part' num2str(i)];
    dist_list{i+old_dists} = [name '-part' num2str(i)];
end

% K-values for set must be re-estimated
handles.set_iscomplete{option} = 0;
    
% Update listbox
set(handles.set_listbox,'String',dist_list);
set(handles.set_listbox,'Value', old_dists+1);

% set toogle state
set(hObject,'Value',0);

% always update the GUI
guidata(hObject, handles);

% --------------------------------------------------------------------
function help_Callback(hObject, eventdata, handles)
% hObject    handle to help (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
helparray{1} = 'Ripley GUI';
helparray{2} = '';
helparray{3} = 'Ripley GUI is a toolbox for exploring the Ripley K-functions in cell distributions';
helparray{4} = '';
helparray{5} = 'Please refer to the RipleyGUI User Manual for complete information on workflow and interpretation'; 
helpdlg(helparray,'Help');

% --------------------------------------------------------------------
function about_Callback(hObject, eventdata, handles)
% hObject    handle to about (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
infoarray{1} = 'RipleyGUI';
infoarray{2} = '';
infoarray{3} = 'Version 1.0';
infoarray{4} = 'Kristin Hansson, Mehrdad Jafari-Mamaghani, Patrik Krieger';
helpdlg(infoarray,'About');

% --------------------------------------------------------------------
function Untitled_1_Callback(hObject, eventdata, handles)
% hObject    handle to Untitled_1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)



function inhib_po_cl_lambda_Callback(hObject, eventdata, handles)
% hObject    handle to inhib_po_cl_lambda (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of inhib_po_cl_lambda as text
%        str2double(get(hObject,'String')) returns contents of inhib_po_cl_lambda as a double


% --- Executes during object creation, after setting all properties.
function inhib_po_cl_lambda_CreateFcn(hObject, eventdata, handles)
% hObject    handle to inhib_po_cl_lambda (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end



function inhib_po_cl_edistance_Callback(hObject, eventdata, handles)
% hObject    handle to inhib_po_cl_edistance (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of inhib_po_cl_edistance as text
%        str2double(get(hObject,'String')) returns contents of inhib_po_cl_edistance as a double


% --- Executes during object creation, after setting all properties.
function inhib_po_cl_edistance_CreateFcn(hObject, eventdata, handles)
% hObject    handle to inhib_po_cl_edistance (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end



function inhib_po_cl_slambda_Callback(hObject, eventdata, handles)
% hObject    handle to inhib_po_cl_slambda (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of inhib_po_cl_slambda as text
%        str2double(get(hObject,'String')) returns contents of inhib_po_cl_slambda as a double


% --- Executes during object creation, after setting all properties.
function inhib_po_cl_slambda_CreateFcn(hObject, eventdata, handles)
% hObject    handle to inhib_po_cl_slambda (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end



function inhib_po_cl_delta_Callback(hObject, eventdata, handles)
% hObject    handle to inhib_po_cl_delta (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of inhib_po_cl_delta as text
%        str2double(get(hObject,'String')) returns contents of inhib_po_cl_delta as a double


% --- Executes during object creation, after setting all properties.
function inhib_po_cl_delta_CreateFcn(hObject, eventdata, handles)
% hObject    handle to inhib_po_cl_delta (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end


% --- Executes on button press in viewSetData.
function viewSetData_Callback(hObject, eventdata, handles)
% hObject    handle to viewSetData (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get the chosen set
option = get(handles.chooseset,'Value');

infostring = [];
% Count distributions
if isfield(handles,'set') == 0 || length(handles.set) < option || length(handles.set{option}) == 0
    infostring = ['Set ', num2str(option),' is empty'];
else
    infostring = ['Set ', num2str(option),' contains ',num2str(length(handles.set{option})), ' distributions',10];
    % Mean size and intensity of distributions
    [sidex sidey sidez lambda] = Get_params(handles.set{option});
    infostring = [infostring,10,'Average lambda = ', num2str(lambda),10,'Average x side length = ', num2str(sidex),10,'Average y side length = ', num2str(sidey), 10, 'Average z side length = ', num2str(sidez),10];

    % Check that K-values are calculated
    if isfield(handles,'set_iscomplete') && length(handles.set_iscomplete) >= option && handles.set_iscomplete{option}
        % Get t and K values
        stepT = handles.set_stept{option};
        maxT = handles.set_maxt{option};
        infostring = [infostring,10,'K-function estimated for t-step ',num2str(stepT), ' and t-max ',num2str(maxT),10];
    else
        infostring = [infostring,10,'Some K-functions remain to be estimated',10];
    end

end

desiredWidth = 300; desiredHeight = 300;
figure('Name',['Set ' num2str(option) ' data'],'Position',getNorthPosition(desiredWidth, desiredHeight))
set(gca,'Visible','off')
text(0,0.7,infostring);
