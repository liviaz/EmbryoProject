function out = create_inhib_po_cl_distribution(lambda, S_lambda, S_sigma, E_distance, delta, x_side, y_side, z_side)
% create_inhib_po_cl_distribution(lambda, S_lambda, S_sigma, E_distance, delta, x_side, y_side, z_side)
% Create a distribution with both simple inhibition and clustering.
% Input:
% lambda     - intensity
% S_lambda   - mean nr of offspring per parent event
% S_sigma    - standard deviation of S
% E_distance - mean distance from offspring to parent
% delta      - area of inhibition
% side       - side of cubic distribution volume
% Output:
% out = [X Y Z] coordinates
%
% License: RipleyGUI is distributed free under the conditions that
% (1) it shall not be incorporated in software that is subsequently sold; 
% (2) the authorship of the software shall be acknowledged in any publication that uses results generated by the software; 
% (3) this notice shall remain in place in each source file. 

parent_intensity = lambda/S_lambda;
parent_events = floor(parent_intensity * x_side*y_side*z_side);
parent_pos = rand(parent_events,3);
xx = parent_pos(:,1) * x_side;
yy = parent_pos(:,2) * y_side;
zz = parent_pos(:,3) * z_side;

req_pack_intensity = lambda * delta^3 *pi/6;
if(req_pack_intensity > pi/48) % not enough space for distribution
    errordlg('There is not space for so many so sparse events. Try lower intensity or less inhibition','Input error');
    out = [];
    return
end

offspring_pos = [];

for i = 1:parent_events
    offspring = (floor(randn(1)*S_sigma+S_lambda));
    j = 0;
    while j < offspring
        R = exprnd(E_distance); % exponential function
        z = rand(1)*2*R - R;
        theta = rand(1)*2*pi;
        phi = asin(z/R);
        [dx dy dz] = sph2cart(theta, phi, R); % random point on sphere of R distance
        new_pos = [xx(i)+dx yy(i)+dy zz(i)+dz];
        % wrapping edges
        new_pos(:,1) = mod(new_pos(:,1), x_side); 
        new_pos(:,2) = mod(new_pos(:,2), y_side);
        new_pos(:,3) = mod(new_pos(:,3), z_side);
        
        discard = 0;
        for ii = 1:size(offspring_pos,1)
            distance = w_distance(offspring_pos(ii,:), new_pos);
            if distance < delta % test if to close another event
                discard = 1; break;
            end
        end
        if discard == 0
            offspring_pos = [offspring_pos; new_pos];
            j = j+1;
        end
    end
end
out = offspring_pos;

